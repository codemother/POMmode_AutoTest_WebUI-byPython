# Beta1.0更新
**我做了什么：**  
1.设计了思维脑图，并尝试用思维脑图的结构对框架进行优化  
2.基本实现了数据和代码的完全分离  


**新的困惑：**  
1.我并没有完全实现预想的框架设计。我无法做到一个界面对象只用一个yaml文件来存放数据而不同的断言对象或操作流程作为一个个大类，每个大类里又有多个同类型的测试用例，这么做无法进行ddt遍历，并且设计出的代码极其繁琐，与我的设计想法不符。我最后的做法是
以界面对象分类在data区创建目录，每个目录下存放不同的断言对象或操作流程数据组成的各个yaml文件。 

2.但是这样我又发现了新的问题，即便是相同的断言对象也会存在如文本不同这样的情况，ddt遍历依然无法做到对同一个testcase代码测试如：（用户名非空，密码为空）（用户名为非空，密码错误）（用户名非空，密码输入位数不足
）这样的用例检测是否符合预期。似乎只要是断言不同，就需要设计新的用例，创建新的yaml文件（如果想用遍历的话）。  

3.于是我开始对我设计的结构产生怀疑，只要断言稍微有所不同我就需要编写不同的testcase代码，即便是一个简单的登录窗口，testcase可能高达上十条。  

4.继而我对POM和自动化测试也产生了思考和怀疑，在webui功能方面，面对大量细微差别的测试用例，设计自动化脚本是否合适？似乎自动化测试只适用于正向的流程（如正常登录），对于反向的各种反馈测试（如确认各种用户输错情况下的反馈信息）似乎并不好用？  

5.到底是我的代码水准和对yaml,ddt的理解程度欠缺还是结构设计不合理抑或是自动化测试确实存在局限性？有待后续学习研究  

ps:点击登录后会弹出滑动验证框，我一直无法定位到这个框中的元素，导致检测弹出框->等待->手动验证的想法无法实现，只能默认等待。尝试了切换iframe页的方法但显示定位不到iframe页。待解决  

# Beta2.0更新
**我做了什么：**  
1.在经过连续7个小时的学习，思考和实践后，我对整个框架的结构再次进行了深度优化，在1.0版本让我陷入困惑和矛盾的很多问题都在2.0版本得到了处理和解决，原本处于比较混沌的逻辑被再次梳理，2.0版本的逻辑思路将是清晰明了的。  

2.在2.0版本中，对于各种不同的测试用例数据要不要写一个新的的testcase方法，我的评判标准是：  
- 首先，这是不是一个新的操作流程，是==要写。  
- 如果不是，这个测试用例会不会用到新类型的断言方式（如：本来都是在原界面断言，现在需要切换iframe/句柄才能断言）或者需要断言多个地方（如：原先的testcase方法只能对一个地方断言，现在需要检测多个地方是否出现了对应元素），是==要写。  
- 我的核心思想是：如果之前的testcase方法需要被修改才能完成测试，那就要编写一个新的testcase方法  
    
3.我认为，断言的核心还是在于判断预期元素有没有出现，比如某个位置的文本是否出现、某个文本是否是预期的值、是否会跳转到新的标签页等等情况，他们最终都是要判断特定元素是否出现。  

4.这也就促成了我将很多参数转变为形参，将一些判断过程打包成方法，相当程度上拓展了测试用例脚本的泛用性，减少了测试用例脚本的代码量，减少了需要新写的testcase方法的数量。  

5.在2.0版本，面对同样的操作流程，我的一个testcase方法支持通过仅修改yaml数据实现对不同元素出现与否的断言。即便是需要断言多个元素，也只需要简单的对testcase和yaml做出一点添加即可。  

**待完善的方面：**  
1.测试报告的生成和所谓环境搭建、持续集成我还没有概念。  

2.目前只完成了login界面的部分流程和测试用例设计，距离整个UI功能测试的自动化还很远  

**新的困惑：**  
1.自动化测试的可行性分析到底如何分析，如何评判一个页面哪些功能是需要自动化的，仅仅是注册登录这些功能吗，这些UI按键的重要级别如何划分？  

2.如果测试用例和数据文件多了的话，就必然需要统一管理，我的这种结构和分类方式是否便于管理和使用？  

3.曾经我的设计理念是testcase的复用性高，同时测试用例文档便于读写。但是目前看来，似乎扩展了testcase的复用性，将大量权限给到yaml测试用例文档后，文档的复杂度会提高很多，需要有一定理解才能使用。不知道路有没有走歪。。。  

PS:在1.0版本我苦思冥想也没能确认的滑动验证框无法定位的问题，经过我对iframe、句柄、xpath等等方面的学习，终于得到了解决。然而这个问题也并不是什么iframe、元素隐藏、定位方法导致的，导致它的最终原因是浏览器没有反应过来，加上sleep完美解决。。。这同时也让我意识到了隐式等待并不能解决所有关于浏览器反应不过来之类的问题，似乎在静态界面上由js导致的动态效果它都不能起到作用。






    


